#!/usr/bin/env python3
"""
Script Principal para Ejecutar el Paquete GitHub-Organizado
==========================================================

Este script permite ejecutar todos los m√≥dulos del paquete de ingenier√≠a
de manera organizada y proporciona un men√∫ interactivo para seleccionar
qu√© m√≥dulo ejecutar.

Autor: Ingenier√≠a Mec√°nica
Versi√≥n: 1.0
"""

import os
import sys
import subprocess
import importlib.util
from typing import Dict, List, Optional
import time


class EjecutorPaquete:
    """
    Clase para ejecutar los m√≥dulos del paquete de ingenier√≠a
    """
    
    def __init__(self):
        self.modulos = {
            "1": {
                "nombre": "An√°lisis Financiero",
                "archivo": "src/analisis/Analisis.py",
                "descripcion": "An√°lisis de OPEX, proyecciones financieras y rentabilidad"
            },
            "2": {
                "nombre": "Gesti√≥n de Mantenimiento",
                "archivo": "src/mantenimiento/gestion_mtto.py",
                "descripcion": "Sistema de gesti√≥n de mantenimiento industrial"
            },
            "3": {
                "nombre": "An√°lisis Estad√≠stico",
                "archivo": "src/estadistica/ESTADISTICA.py",
                "descripcion": "An√°lisis estad√≠stico completo para ingenier√≠a"
            },
            "4": {
                "nombre": "An√°lisis de Vigas (SFD/BMD)",
                "archivo": "src/ingenieria/sfd1.py",
                "descripcion": "Diagramas de fuerza cortante y momento flector"
            },
            "5": {
                "nombre": "Sistema de Graficaci√≥n",
                "archivo": "src/ingenieria/Graph_durant.py",
                "descripcion": "Sistema avanzado de visualizaci√≥n para ingenier√≠a"
            },
            "6": {
                "nombre": "Curvas de Bombas",
                "archivo": "src/ingenieria/CURVA_BOMBA.py",
                "descripcion": "An√°lisis de curvas de bombas y sistemas de flujo"
            },
            "7": {
                "nombre": "M√©todos Num√©ricos",
                "archivo": "src/ingenieria/RUNGE_KUTTA.py",
                "descripcion": "Implementaci√≥n de m√©todos num√©ricos"
            },
            "8": {
                "nombre": "Curvas de Mantenimiento",
                "archivo": "src/ingenieria/curva_mtto.py",
                "descripcion": "An√°lisis de curvas de mantenimiento"
            }
        }
        
        self.herramientas = {
            "setup": {
                "nombre": "Configuraci√≥n del Paquete",
                "archivo": "setup.py",
                "descripcion": "Configurar entorno del paquete"
            },
            "ejemplo": {
                "nombre": "Ejemplo de Uso Completo",
                "archivo": "ejemplo_uso_completo.py",
                "descripcion": "Ejemplo integrado de todas las funcionalidades"
            }
        }
    
    def mostrar_menu_principal(self):
        """Mostrar men√∫ principal del paquete"""
        print("\n" + "=" * 70)
        print("           PAQUETE GITHUB-ORGANIZADO - INGENIER√çA")
        print("=" * 70)
        print("\nüìö M√≥dulos de Ingenier√≠a Disponibles:")
        print("-" * 50)
        
        for clave, modulo in self.modulos.items():
            print(f"{clave}. {modulo['nombre']}")
            print(f"   üìÅ {modulo['archivo']}")
            print(f"   üìù {modulo['descripcion']}")
            print()
        
        print("üõ†Ô∏è Herramientas de Sistema:")
        print("-" * 50)
        for clave, herramienta in self.herramientas.items():
            print(f"{clave}. {herramienta['nombre']}")
            print(f"   üìÅ {herramienta['archivo']}")
            print(f"   üìù {herramienta['descripcion']}")
            print()
        
        print("üìã Comandos Especiales:")
        print("-" * 50)
        print("todos    - Ejecutar todos los m√≥dulos en secuencia")
        print("test     - Ejecutar tests del paquete")
        print("info     - Mostrar informaci√≥n del paquete")
        print("setup    - Configurar entorno del paquete")
        print("salir    - Salir del programa")
        print()
    
    def verificar_archivo(self, archivo: str) -> bool:
        """
        Verificar si un archivo existe
        
        Args:
            archivo: Ruta del archivo
            
        Returns:
            bool: True si el archivo existe
        """
        return os.path.exists(archivo)
    
    def ejecutar_modulo(self, clave: str) -> bool:
        """
        Ejecutar un m√≥dulo espec√≠fico
        
        Args:
            clave: Clave del m√≥dulo a ejecutar
            
        Returns:
            bool: True si se ejecut√≥ correctamente
        """
        if clave in self.modulos:
            modulo = self.modulos[clave]
            archivo = modulo['archivo']
            
            if not self.verificar_archivo(archivo):
                print(f"‚ùå Error: Archivo '{archivo}' no encontrado")
                return False
            
            print(f"\n{'='*70}")
            print(f"üöÄ EJECUTANDO: {modulo['nombre']}")
            print(f"{'='*70}")
            print(f"üìÅ Archivo: {archivo}")
            print(f"üìù Descripci√≥n: {modulo['descripcion']}")
            print(f"{'='*70}\n")
            
            return self._ejecutar_archivo(archivo)
        
        elif clave in self.herramientas:
            herramienta = self.herramientas[clave]
            archivo = herramienta['archivo']
            
            if not self.verificar_archivo(archivo):
                print(f"‚ùå Error: Archivo '{archivo}' no encontrado")
                return False
            
            print(f"\n{'='*70}")
            print(f"üõ†Ô∏è EJECUTANDO: {herramienta['nombre']}")
            print(f"{'='*70}")
            print(f"üìÅ Archivo: {archivo}")
            print(f"üìù Descripci√≥n: {herramienta['descripcion']}")
            print(f"{'='*70}\n")
            
            return self._ejecutar_archivo(archivo)
        
        else:
            print(f"‚ùå Error: M√≥dulo '{clave}' no encontrado")
            return False
    
    def _ejecutar_archivo(self, archivo: str) -> bool:
        """
        Ejecutar un archivo Python espec√≠fico
        
        Args:
            archivo: Ruta del archivo a ejecutar
            
        Returns:
            bool: True si se ejecut√≥ correctamente
        """
        try:
            # Verificar dependencias
            if not self._verificar_dependencias():
                print("‚ö†Ô∏è Algunas dependencias pueden no estar instaladas")
                print("Ejecute 'setup' para instalar dependencias")
            
            # Ejecutar el archivo
            resultado = subprocess.run([sys.executable, archivo], 
                                     capture_output=True, 
                                     text=True, 
                                     cwd=os.getcwd())
            
            # Mostrar salida
            if resultado.stdout:
                print(resultado.stdout)
            
            if resultado.stderr:
                print("‚ö†Ô∏è Advertencias/Errores:")
                print(resultado.stderr)
            
            if resultado.returncode == 0:
                print(f"‚úÖ M√≥dulo ejecutado exitosamente")
                return True
            else:
                print(f"‚ùå Error al ejecutar el m√≥dulo (c√≥digo: {resultado.returncode})")
                return False
                
        except Exception as e:
            print(f"‚ùå Error inesperado: {str(e)}")
            return False
    
    def _verificar_dependencias(self) -> bool:
        """
        Verificar si las dependencias principales est√°n instaladas
        
        Returns:
            bool: True si las dependencias est√°n disponibles
        """
        dependencias = ['pandas', 'numpy', 'matplotlib', 'seaborn', 'scipy']
        disponibles = 0
        
        for dep in dependencias:
            try:
                importlib.import_module(dep)
                disponibles += 1
            except ImportError:
                pass
        
        return disponibles >= 3  # Al menos 3 de 5 dependencias principales
    
    def ejecutar_todos_modulos(self):
        """Ejecutar todos los m√≥dulos en secuencia"""
        print("\n" + "=" * 70)
        print("üöÄ EJECUTANDO TODOS LOS M√ìDULOS DEL PAQUETE")
        print("=" * 70)
        
        exitos = 0
        total = len(self.modulos)
        
        for clave in self.modulos.keys():
            print(f"\n{'='*50}")
            print(f"üìä Progreso: {exitos}/{total} m√≥dulos completados")
            print(f"{'='*50}")
            
            if self.ejecutar_modulo(clave):
                exitos += 1
            
            print("\n‚è≥ Esperando 3 segundos antes del siguiente m√≥dulo...")
            time.sleep(3)
        
        print(f"\n{'='*70}")
        print(f"üìà RESUMEN: {exitos}/{total} m√≥dulos ejecutados exitosamente")
        print(f"{'='*70}")
        
        if exitos == total:
            print("üéâ ¬°Todos los m√≥dulos se ejecutaron correctamente!")
        elif exitos >= total * 0.8:
            print("‚úÖ La mayor√≠a de los m√≥dulos se ejecutaron correctamente")
        else:
            print("‚ö†Ô∏è Algunos m√≥dulos tuvieron problemas")
    
    def ejecutar_tests(self):
        """Ejecutar tests del paquete"""
        print("\n" + "=" * 70)
        print("üß™ EJECUTANDO TESTS DEL PAQUETE")
        print("=" * 70)
        
        # Verificar si existe directorio de tests
        if not os.path.exists("tests"):
            print("‚ùå Directorio 'tests' no encontrado")
            return
        
        try:
            # Ejecutar tests con pytest si est√° disponible
            resultado = subprocess.run([sys.executable, "-m", "pytest", "tests", "-v"], 
                                     capture_output=True, text=True)
            
            if resultado.stdout:
                print(resultado.stdout)
            
            if resultado.stderr:
                print("‚ö†Ô∏è Advertencias:")
                print(resultado.stderr)
            
            if resultado.returncode == 0:
                print("‚úÖ Tests ejecutados exitosamente")
            else:
                print("‚ùå Algunos tests fallaron")
                
        except Exception as e:
            print(f"‚ùå Error al ejecutar tests: {str(e)}")
            print("üí° Aseg√∫rese de tener pytest instalado: pip install pytest")
    
    def mostrar_informacion_paquete(self):
        """Mostrar informaci√≥n detallada del paquete"""
        print("\n" + "=" * 70)
        print("üìö INFORMACI√ìN DEL PAQUETE GITHUB-ORGANIZADO")
        print("=" * 70)
        
        print("\nüéØ Prop√≥sito del Paquete:")
        print("-" * 30)
        print("Este paquete contiene herramientas completas de ingenier√≠a")
        print("organizadas por disciplinas y especialidades t√©cnicas.")
        print("Dise√±ado para an√°lisis, c√°lculos y visualizaciones profesionales.")
        
        print("\nüìÅ Estructura del Paquete:")
        print("-" * 30)
        print("github-organizado/")
        print("‚îú‚îÄ‚îÄ src/")
        print("‚îÇ   ‚îú‚îÄ‚îÄ analisis/          - An√°lisis financiero y operativo")
        print("‚îÇ   ‚îú‚îÄ‚îÄ mantenimiento/     - Gesti√≥n de mantenimiento")
        print("‚îÇ   ‚îú‚îÄ‚îÄ estadistica/       - An√°lisis estad√≠stico")
        print("‚îÇ   ‚îú‚îÄ‚îÄ ingenieria/        - Herramientas de ingenier√≠a")
        print("‚îÇ   ‚îú‚îÄ‚îÄ gui/              - Interfaces gr√°ficas")
        print("‚îÇ   ‚îî‚îÄ‚îÄ web/              - Aplicaciones web")
        print("‚îú‚îÄ‚îÄ tests/                - Tests unitarios")
        print("‚îú‚îÄ‚îÄ docs/                 - Documentaci√≥n")
        print("‚îú‚îÄ‚îÄ data/                 - Datos de ejemplo")
        print("‚îî‚îÄ‚îÄ assets/               - Recursos multimedia")
        
        print("\nüîß M√≥dulos Principales:")
        print("-" * 30)
        for clave, modulo in self.modulos.items():
            print(f"‚Ä¢ {modulo['nombre']}: {modulo['descripcion']}")
        
        print("\nüì¶ Dependencias Principales:")
        print("-" * 30)
        dependencias = [
            "pandas - An√°lisis de datos",
            "numpy - C√°lculos num√©ricos",
            "matplotlib - Visualizaciones",
            "seaborn - Gr√°ficos estad√≠sticos",
            "scipy - Funciones cient√≠ficas",
            "plotly - Gr√°ficos interactivos",
            "streamlit - Aplicaciones web"
        ]
        for dep in dependencias:
            print(f"‚Ä¢ {dep}")
        
        print("\nüöÄ C√≥mo Usar:")
        print("-" * 30)
        print("1. Ejecute 'setup' para configurar el entorno")
        print("2. Seleccione un m√≥dulo espec√≠fico (1-8)")
        print("3. Ejecute 'todos' para probar todos los m√≥dulos")
        print("4. Use 'ejemplo' para ver un caso de uso completo")
        
        print("\nüìã Archivos Importantes:")
        print("-" * 30)
        archivos_importantes = [
            "setup.py - Configuraci√≥n del paquete",
            "requirements.txt - Dependencias",
            "README.md - Documentaci√≥n principal",
            "ejemplo_uso_completo.py - Ejemplo integrado"
        ]
        for archivo in archivos_importantes:
            print(f"‚Ä¢ {archivo}")
    
    def ejecutar_comando_especial(self, comando: str) -> bool:
        """
        Ejecutar comandos especiales
        
        Args:
            comando: Comando a ejecutar
            
        Returns:
            bool: True si el comando se ejecut√≥ correctamente
        """
        if comando.lower() == "todos":
            self.ejecutar_todos_modulos()
            return True
        
        elif comando.lower() in ["test", "tests"]:
            self.ejecutar_tests()
            return True
        
        elif comando.lower() == "setup":
            return self.ejecutar_modulo("setup")
        
        elif comando.lower() == "info":
            self.mostrar_informacion_paquete()
            return True
        
        elif comando.lower() in ["salir", "exit", "quit"]:
            print("\nüëã ¬°Gracias por usar el Paquete GitHub-Organizado!")
            print("¬°Esperamos que las herramientas de ingenier√≠a sean √∫tiles!")
            sys.exit(0)
        
        else:
            print(f"‚ùå Comando '{comando}' no reconocido")
            return False
    
    def ejecutar_interactivo(self):
        """Ejecutar el paquete en modo interactivo"""
        print("üîß Bienvenido al Paquete GitHub-Organizado de Ingenier√≠a")
        print("Ejecutando en modo interactivo...")
        
        while True:
            try:
                self.mostrar_menu_principal()
                
                # Obtener entrada del usuario
                entrada = input("Selecciona un m√≥dulo o comando: ").strip()
                
                if not entrada:
                    continue
                
                # Ejecutar m√≥dulo o comando
                if entrada in self.modulos or entrada in self.herramientas:
                    self.ejecutar_modulo(entrada)
                else:
                    self.ejecutar_comando_especial(entrada)
                
                print("\n‚è≥ Presiona Enter para continuar...")
                input()
                
            except KeyboardInterrupt:
                print("\n\nüëã ¬°Hasta luego!")
                sys.exit(0)
            except Exception as e:
                print(f"\n‚ùå Error inesperado: {str(e)}")
                print("Continuando...")


def main():
    """Funci√≥n principal"""
    ejecutor = EjecutorPaquete()
    
    # Verificar argumentos de l√≠nea de comandos
    if len(sys.argv) > 1:
        comando = sys.argv[1]
        
        if comando in ejecutor.modulos or comando in ejecutor.herramientas:
            ejecutor.ejecutar_modulo(comando)
        else:
            ejecutor.ejecutar_comando_especial(comando)
    else:
        # Modo interactivo
        ejecutor.ejecutar_interactivo()


if __name__ == "__main__":
    main() 